```{r}
library(dplyr)
library(tidyr)
library(furrr)
library(purrr)

# Recursive function to get ancestors up to k generations, including sex and lineage
get_ancestors <- function(pedigree, inds, k, current_generation = 0, lineage = "") {
  if (k < 0 || length(inds) == 0) {
    return(data.frame(ancestor = integer(0), generation = integer(0), sex = integer(0), lineage = character(0)))
  } else {
    current_ancestors <- data.frame(ancestor = inds, generation = current_generation, lineage = lineage) %>%
      left_join(pedigree %>% select(ind, sex), by = c("ancestor" = "ind"))
    
    parents <- pedigree %>%
      filter(ind %in% inds) %>%
      select(father, mother)
    
    # For father's side, append 'paternal' to lineage
    ancestors_father <- get_ancestors(pedigree, na.omit(parents$father), k - 1, current_generation + 1, lineage = paste(lineage, "p", sep = ">"))
    
    # For mother's side, append 'maternal' to lineage
    ancestors_mother <- get_ancestors(pedigree, na.omit(parents$mother), k - 1, current_generation + 1, lineage = paste(lineage, "m", sep = ">"))
    
    all_ancestors <- bind_rows(current_ancestors, ancestors_father, ancestors_mother) %>%
      distinct()
    
    return(all_ancestors)
  }
}

# Function to get all ancestors for each proband up to k generations, parallelized with furrr
get_all_ancestors_furrr <- function(pedigree, list_of_probands, k) {
  # Plan for parallel processing using available cores
  plan(multisession, workers = future::availableCores() - 1)
  
  # Use future_map instead of lapply for parallel execution
  all_ancestors <- future_map_dfr(list_of_probands, function(proband) {
    ancestors <- get_ancestors(pedigree, proband, k)
    ancestors$proband <- proband
    return(ancestors)
  })
  
  # Remove missing ancestors
  all_ancestors <- all_ancestors %>% filter(!is.na(ancestor))
  
  return(all_ancestors)
}

# Function to identify common ancestors and group relatives by ancestor and generation
identify_common_ancestors <- function(all_ancestors) {
  # Remove lineage from grouping to include all probands sharing the same ancestor
  common_ancestors <- all_ancestors %>%
    group_by(ancestor, generation) %>%
    filter(n_distinct(proband) > 1) %>%
    ungroup()
  
  return(common_ancestors)
}

# Function to group relatives based on shared ancestors
group_relatives <- function(common_ancestors) {
  # Define relationships based on the generation of the shared ancestor
  relatives <- common_ancestors %>%
    mutate(relationship = case_when(
      generation == 1 ~ "siblings",
      generation == 2 ~ "first_cousins",
      generation == 3 ~ "second_cousins",
      TRUE ~ paste0(generation - 1, "_degree_relatives")
    ))
  
  # Create all pair combinations of probands for each common ancestor
  relative_pairs <- relatives %>%
    select(proband, ancestor, generation, sex, lineage, relationship) %>%
    group_by(ancestor, generation, relationship) %>%
    summarise(
      pairs = list(as.data.frame(t(combn(proband, 2)))), # Ensure `combn` output is in the correct format
      .groups = "drop"
    ) %>%
    unnest_longer(pairs) %>% # Expand list into rows
    unnest_wider(pairs) %>% # Separate columns for proband1 and proband2
    rename(proband1 = V1, proband2 = V2)
  
  # Add symmetry by swapping probands and duplicating rows
  symmetric_pairs <- relative_pairs %>%
    mutate(temp = proband1, proband1 = proband2, proband2 = temp) %>%
    select(-temp)
  
  # Combine original and symmetric pairs
  all_pairs <- bind_rows(relative_pairs, symmetric_pairs) %>%
    distinct() # Remove any duplicates if they exist
  
  # Add lineage for proband1 only
  all_pairs <- all_pairs %>%
    left_join(
      relatives %>% select(proband, ancestor, lineage) %>% rename(lineage1 = lineage),
      by = c("proband1" = "proband", "ancestor" = "ancestor")
    )
  
  return(all_pairs)
}


# Main function to identify and classify relative types among probands
identify_related_probands <- function(pedigree, list_of_probands, k) {
  # Step 1: Get all ancestors up to generation k
  all_ancestors <- get_all_ancestors_furrr(pedigree, list_of_probands, k)
  
  # Step 2: Identify common ancestors among probands
  common_ancestors <- identify_common_ancestors(all_ancestors)
  
  # Step 3: Group relatives based on shared ancestors and their generation
  relatives <- group_relatives(common_ancestors)
  
  # Return the result
  return(relatives)
}

# Function to find the complete list of relatives for each focal proband
find_complete_relatives <- function(relatives) {
  # Compile all relatives for each proband
  complete_relatives <- relatives %>%
    group_by(proband1) %>%
    summarise(
      relatives = list(proband2), # List of all relatives
      relationships = list(unique(relationship)), # Unique relationship types
      lineages = list(unique(lineage1)), # Unique lineages
      num_relatives = n(), # Total number of relatives
      num_relationship_types = length(unique(relationship)), # Number of unique relationship types
      .groups = "drop"
    )
    
  # Format the complete_relatives data frame for better readability
  complete_relatives_readable <- complete_relatives %>%
    mutate(
      relatives = sapply(relatives, function(x) paste(x, collapse = ", ")), # Convert list to comma-separated string
      relationships = sapply(relationships, function(x) paste(x, collapse = ", ")), # Convert list to string
      lineages = sapply(lineages, function(x) paste(x, collapse = ", ")) # Convert list to string
    )
  
  return(complete_relatives_readable)
}

# Function to arrange relatives by lineage
arrange_relatives_by_lineage <- function(complete_relatives, relatives) {
  # Add the lineage of each relative (proband2) from the original relatives data
  relatives_with_lineage <- relatives %>%
    select(proband1, proband2, lineage1) %>%
    rename(relative = proband2, lineage = lineage1)
  
  # For each proband1, group relatives by their lineages
  arranged_relatives <- complete_relatives %>%
    rowwise() %>%
    mutate(
      relatives_by_lineage = list(
        relatives_with_lineage %>%
          filter(proband1 == proband1) %>%
          arrange(lineage) %>%
          select(relative, lineage)
      )
    ) %>%
    ungroup() %>%
    mutate(
      relatives = sapply(relatives, function(x) paste(x, collapse = ", ")), # Convert list to comma-separated string
      relationships = sapply(relationships, function(x) paste(x, collapse = ", ")), # Convert list to string
      lineages = sapply(lineages, function(x) paste(x, collapse = ", ")) # Convert list to string
    )
  
  return(arranged_relatives)
}



```

```{r}
# Download sample pedigree
url <- "https://raw.githubusercontent.com/LukeAndersonTrocme/genome_simulations/main/quick_start/pedigrees/sample_pedigree.csv"
destination <- "/Users/luke/Desktop/sample_pedigree.csv"
download.file(url, destination)

pedigree <- data.table::fread(destination) %>% 
  filter(mother != 0, father != 0, ind != 0)

list_of_probands <- pedigree %>% 
  filter(!ind %in% c(pedigree$mother, pedigree$father)) %>% 
  pull(ind) 

relatives <- identify_related_probands(pedigree, list_of_probands, k = 5) 

# Process relatives to keep only the closest relationship for each pair
relatives <- relatives %>%
  group_by(proband1, proband2) %>%
  filter(generation == min(generation)) %>%
  ungroup() %>%
  distinct()

# Arrange by generation
relatives %>% arrange(generation, ancestor)

# Find probands with the most complete set of relatives
probands_relatives_info <- find_complete_relatives(relatives)

probands_relatives_info%>%
  arrange(-num_relationship_types, -num_relatives) %>%
  print(n = 10)

probands_with_most_relatives <- probands_relatives_info$probands_with_most_relatives

# View the probands with the most complete set of relatives
probands_with_most_relatives


```